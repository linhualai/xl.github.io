<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Posts</title>
    <link href="http://veryr.com/atom.xml" rel="self" />
    <link href="http://veryr.com" />
    <id>http://veryr.com/atom.xml</id>
    <author>
        <name>Linhua Lai</name>
        <email>linhua.lai@gmail.com</email>
    </author>
    <updated>2013-11-27T00:00:00Z</updated>
    <entry>
    <title>Postgres 中的简单压缩算法</title>
    <link href="http://veryr.com/posts/simple_lz_compress/" />
    <id>http://veryr.com/posts/simple_lz_compress/</id>
    <published>2013-11-27T00:00:00Z</published>
    <updated>2013-11-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Postgres 的页面(page)大小是固定的 8k，同一行的数据必须在同一个页面内，但是 Postgres 需要支持变长的数据类型(如 varchar)，是可能超过 8k 的。解决方案是所谓的 <a href="http://www.postgresql.org/docs/current/static/storage-toast.html">TOAST</a> (The Oversized-Attribute Storage Technique, 过长字段存储技术)。</p>
<p>TOAST 解决的思路一个是压缩，一个是页外存储。两个可以结合：页外压缩存储。页外存储就是在每个有变长字段表的 table 存储文件外再创建一个 .toast 结尾文件，过长字段存放在 .toast 文件，并将 offset 放在原 table 文件中替代。这样还能提高扫表的速度(如果此次查询不需要这个字段的话)。</p>
<p>Postgres 的压缩采用的是一个极简单的 lz 字典压缩算法。从解压过程来理解其原理的话非常简单：</p>
<pre><code>sp= 11110000 | 0x41 | 0x42 | 0x43 | 0x44 | 0x01 | 0x00 | 0x05 | 0x00 | 0x09 | 0x00 | 0x0f | 0x00  | 0x0e  |
    ———————————————————————————————————————————————————————————————————————————————————————————————————————
    control  | data | data | data | data | len4 + off12| len4 + off12| len4 + off12| len4 + off12 | len8  |
    ———————————————————————————————————————————————————————————————————————————————————————————————————————
             | &#39;A&#39;  | &#39;B&#39;  | &#39;C&#39;  | &#39;D&#39;  | len:4 off:0 | len:8 off:0 | len:16 off:0| len:18 off:0 | len:14|
    ____________|      |      |      |         |             |             |              |              |
    |__________________|      |      |         |             |             |              |       +      |
    ||________________________|      |         |             |             |              |———————————————
    |||______________________________|         |             |             |              |
    ||||  _____________________________________|             |             |              |
    ||||  |     _____________________________________________|             |              |
    ||||  |     |          ________________________________________________|              |
    ||||  |     |          |                       _______________________________________|
    ||||  |     |          |                       |
    ||||{4-}{---8--}{------16------}{--------------32--------------}
dp= ABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCDABCD</code></pre>
<p>sp = [oxf0,0x41,0x42,0x43,0x44,0x01,0x00,0x05,0x00,0x09,0x00,0x0d,0x00,0x0e] 这样的一个压缩串能解压成什么呢？首先，先读一个 control byte，在这个例子里面就是 0xf0，也就是二进制的 11110000。从最低位开始看：</p>
<ul>
<li>每看到一个 0 bit，就将 sp 的下一个字节原样写到结果 dp 里。</li>
<li>每看到一个 1 bit，就再读两个字节 byte1 和 byte2, len = [byte1 的低4位] + 3，off = [byte1 的高4位] * 256 + [byte2]。如果 len == 18, 那么再读一个字节 byte3，len += byte3。然后从 dp 的末尾往前 off 个字节拷贝 len 个字节到 dp 里。</li>
</ul>
<p>这样我们一个长度为14字节的 sp 解压成一个 长度为64字节的dp，压缩比为14/64 ~= 22%。代码在 postgres/src/backend/utils/adt/pg_lzcompress.c 。简单利落得令人发指。</p>
<pre lang="c"><code>void pglz_decompress(const PGLZ_Header *source, char *dest) {
	const unsigned char *sp;
	const unsigned char *srcend;
	unsigned char *dp;
	unsigned char *destend;
	sp = ((const unsigned char *) source) + sizeof(PGLZ_Header);
	srcend = ((const unsigned char *) source) + VARSIZE(source);
	dp = (unsigned char *) dest;
	destend = dp + source-&gt;rawsize;
	while (sp &lt; srcend &amp;&amp; dp &lt; destend) {
		unsigned char ctrl = *sp++;
		int			ctrlc;
		for (ctrlc = 0; ctrlc &lt; 8 &amp;&amp; sp &lt; srcend; ctrlc++) {
			if (ctrl &amp; 1)
			{
				int32		len;
				int32		off;

				len = (sp[0] &amp; 0x0f) + 3;
				off = ((sp[0] &amp; 0xf0) &lt;&lt; 4) | sp[1];
				sp += 2;
				if (len == 18)
					len += *sp++;
				if (dp + len &gt; destend) {
					dp += len;
					break;
				}
				while (len--) {
					*dp = dp[-off];
					dp++;
				}
			}
			else {
				if (dp &gt;= destend)		/* check for buffer overrun */
					break;				/* do not clobber memory */

				*dp++ = *sp++;
			}
			ctrl &gt;&gt;= 1; 				/* Advance the control bit */
		}
	}
}
</code></pre>
<p>再来看压缩过程，压缩比解压复杂，就好比给车打气比放气难，又好比吃饭比做饭容易，又好比考公务员比下海难。代码的实现比较复杂，但是原理还是比较直观的。</p>
<p>给定一个待压缩串 source，压缩的结果输出到 dest。数据还是用上面的例子，只是过程反过来。</p>
<ul>
<li>如果 control byte 没有分配或已经用完的话，在 dest 里分配一个 control byte</li>
<li>取 source 串的下一个待压缩序列长度至少为 3 的尽量长的序列</li>
<li>如果在已压缩的 source 串中能找到一个连续的串和待压缩串相同，那么 control bit 置 1，并将 source 串中的 offset 和 len 写入 dest。</li>
<li>如果没有找到，那么将 control bit 置 0，将 source 中的下一个字节直接写入 dest。</li>
</ul>
<p>如此重复，直到压缩完成 source 串中的所有字节为止。具体代码可以参看 pglz_decompress.c 文件。</p>]]></summary>
</entry>
<entry>
    <title>Postgres 的文件存储位置</title>
    <link href="http://veryr.com/posts/postgres-storage-location/" />
    <id>http://veryr.com/posts/postgres-storage-location/</id>
    <published>2013-11-21T00:00:00Z</published>
    <updated>2013-11-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>initdb 的时候会指定一个 PGDATA 目录，这就是 PostgresQL 存储数据的地方。典型的位置是在 /var/lib/postgres/data 或 /home/postgres/data 。PGDATA 下面各项存储的内容大概是：</p>
<table>
<thead>
<tr class="header">
<th style="text-align: left;">文件或目录名</th>
<th style="text-align: left;">存储内容</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">PG_VERSION</td>
<td style="text-align: left;">PostgresQL 实例的版本号如 9.3 之类的</td>
</tr>
<tr class="even">
<td style="text-align: left;">base</td>
<td style="text-align: left;">每个 database 会在 base 目录下有一个子目录</td>
</tr>
<tr class="odd">
<td style="text-align: left;">global</td>
<td style="text-align: left;">Postgres 自己的 meta 数据库存放的地方（全局 DB）</td>
</tr>
<tr class="even">
<td style="text-align: left;">pg_xlog</td>
<td style="text-align: left;">WAL(Write Ahead Log 预写式日志）存放的地方</td>
</tr>
<tr class="odd">
<td style="text-align: left;">其他</td>
<td style="text-align: left;">其他不知道干啥的目录还有好多</td>
</tr>
</tbody>
</table>
<p>base 目录是最重要的一个目录，放的是每一个 database 的数据。base 目录里的每一个数字目录对于一个 database 的 oid， 可以通过 查看 pg_database 这张表查看每一个 数据库的 oid 。</p>
<pre><code>lai=# select oid, datname from pg_database ;
  oid  |  datname  
-------+-----------
     1 | template1
 12031 | template0
 12036 | postgres
 16385 | lai
(4 rows)</code></pre>
<p>每一张表的数据（大部分）又是放在 base/(dboid)/(relfilenode) 这个文件里面：</p>
<pre><code>lai=# select relname, relowner, relfilenode from pg_class where relowner = 16384;
        relname        | relowner | relfilenode 
-----------------------+----------+-------------
 pg_toast_24589        |    16384 |       24592
 pg_toast_24589_index  |    16384 |       24594
 pg_toast_24595        |    16384 |       24598
 pg_toast_24595_index  |    16384 |       24600
 item_id_seq           |    16384 |       24601
 Feed_pkey             |    16384 |      167963
 feed                  |    16384 |       24589
 item                  |    16384 |       24595
 pg_toast_168003       |    16384 |      168006
 pg_toast_168003_index |    16384 |      168008
 tmp                   |    16384 |      168003
(11 rows)</code></pre>
<p>feed 这张表数据在 base/16386/24589 文件里，item 这张表的数据放在 base/16386/24595 这个文件里。也可以用 pg_relation_filepath 这个函数查询：</p>
<pre><code>lai=# select pg_relation_filepath(&#39;item&#39;);
 pg_relation_filepath 
----------------------
 base/16385/24595
(1 row)</code></pre>
<p>当然实际的存储不会这么简单。每一张表的文件都会有一些附加的存储文件，如文件名后加上 _fsm 的是空闲空间映射表 (Free Space Map)。另外 base/(dboid)/(relfilenode) 这个文件超过 1GB 以后，Postgres 会把这个文件拆分成不超过 1G 的多个文件，文件末尾加上 .1 .2 .3 … 做编号。 如 24589 24589.1 24589.2 。据说这是因为某些文件系统支持的最大文件大小有限制(如 fat32 只支持最大 4G )的文件。</p>]]></summary>
</entry>
<entry>
    <title>论如何才能拿到一个博士学位</title>
    <link href="http://veryr.com/posts/you-need-to-get-phd/" />
    <id>http://veryr.com/posts/you-need-to-get-phd/</id>
    <published>2013-11-14T00:00:00Z</published>
    <updated>2013-11-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>王同学上周又有高论，把 OOP 和 FP 都喷了一遍。文章被人贴到 <a href="https://news.ycombinator.com/item?id=6716399">HN</a> 和 <a href="http://www.reddit.com/r/programming/comments/1qg5x8/whats_wrong_with_oop_and_fp/">Reddit</a> 上，被几个明白人扔了两板砖。立马就把文章给改了，标题都从 Whats wrong with Object-Oriented Programming and Functional Programming 这种还有点意思的改成 <a href="https://yinwang0.wordpress.com/2013/11/09/oop-fp/">Pure OOP and Pure FP</a>，还顺手吧评论删了，关了。我说王同学这就没意思了。你之前说 OOP 和 FP 是两砣那啥，虽然逻辑不行，至少还能让大家讨论讨论，引玉出来，你现在的这打这哈哈说 OOP 和 FP 有未必好，没有未必不好，该用的时候用，不该用的时候不要滥用，你说这和没说有甚么分别？</p>
<p>OOP 咱不了解，话说 FP 的话王同学的高论不过就是说物理世界是有状态的，有副作用的，所以用无状态的，纯函数的 FP 来写代码处理是不行的。王同学怎么说也是念过博士的人是吧，咋还一点基本的科学素养也没有。世界是有状态的？这话物理学家也未必这么利器在手，自信满满可以这么说吧？退一步讲世界是 stateful 的又如何，难道不能用纯函数去描述？假如物质是量子的、离散的，我们就不能用连续的数学函数去描述物体的运动？</p>
<p>经济学里也有个规范分析和实证分析的区别，实证分析研究“是什么”，规范分析研究“该怎样”。某地发生地震了，根据供需关系物价会上涨，这在描述一个事实，是实证分析。在地震的地区该不该管理坐地起价的行为，分别有什么利弊，这个是规范分析。两个都能弄错，也是国人的常态，大概也是出国了也拿不到博士学位的原因。</p>]]></summary>
</entry>
<entry>
    <title>为什么我觉得 360 搜索能成功</title>
    <link href="http://veryr.com/posts/360-search/" />
    <id>http://veryr.com/posts/360-search/</id>
    <published>2013-03-03T00:00:00Z</published>
    <updated>2013-03-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="百度">百度</h2>
<p>先看看为什么百度能打败 Google.</p>
<ol type="1">
<li>Google 和政府关系不好, 在05, 06年中国人的搜索习惯的开始形成的关键时间点上不间断的被 GFW reset 连接.</li>
<li>Baidu 线下工作做得好, 派人挨个网吧给点钱让把首页设成 Baidu. 积级联系代理商拉客户. 这是 Google 不会做, 不屑于做的 “不酷”的事, Baidu 做好了.</li>
</ol>
<p>可以说是流氓打败了贵族, 也可以说是务实打败了清高.</p>
<h2 id="搜索格局为什么难有大变动">搜索格局为什么难有大变动</h2>
<p>这几年不论国内国外, 搜索的格局一直没怎么变. 即使是微软这个财主, 对Bing的持续投入已达数十亿美元, 却依然撬不动 Google 的一点份额. 腾讯 soso 数十亿的投入也如打水漂了. 为什么说 360 就能成事呢?</p>
<p>搜索的技术壁垒基本上没有了, 连盘古, 即刻这些个国家队上场的时候更加说明了这一点. 问题在两边: 用户和客户.</p>
<ul>
<li>用户这边</li>
</ul>
<p>由于上文说的搜索的技术壁垒基本没有, 结果说就是大家的搜索质量最差不太远, 也就是多索引了些和少索引了些的区别, 因为用户需要的内容一般都在前几页, 所以没什么影响. 那怎么拉用户? 一是用户习惯, 这个不说了; 二是软件预装, 这说是巨头都做浏览器的原因, Google 的浏览器做得好, 微软的做的不好, 所以微软的搜索份额上不去. 腾讯的浏览器做得了不好, 所以搜索上不去, 搜狗的浏览器做得好, 搜索的份额就抢到一点. 360也是. Baidu 浏览器没啥份额, 但是人捆绑插件做得好(:D).</p>
<ul>
<li>客户这边</li>
</ul>
<p>有了流量怎么变现? 这个各家技术就有区分度了. Facebook 的一名早期员工 Hammerbacher 曾说过这么一句话: &gt; 我这代人中最聪明的大脑都在思索如何让人们点击广告，很操蛋。</p>
<p>Google 靠的是机器学习, 通过海量的数据挖掘来, 通过用户的搜索习惯来找到用户的兴趣, 把用户再卖给客户. 这个精确程度能决定你变现的能力. 而且是数据量越大, 挖掘越精准, 变现越容易. 所以 Google 和 Baidu 在这方面的优势只会越来越大.</p>
<p>用户那边其实不重要, 客户这边没变现才很致命. 无收入意味得撑不久, 所以 soso 撤了.</p>
<h2 id="为什么说-360-能够成功">为什么说 360 能够成功</h2>
<p>那就是比百度更加流氓, 更加务实.</p>
<ol type="1">
<li>拉用户无所不用, “安全卫士” 捆绑 “安全浏览器”, “安全浏览器” 捆绑 “安全搜索”, 圆环套圆环, 一条龙服务.</li>
<li>别人不敢用的变现手段. 这才是 360 的杀手锏.</li>
</ol>
<p>我现在也在做广告投放, 海量数据的机器挖掘有个很大的弱点: 无法精确定位一个人. 传统的 Cookie, Flash Cookie, 随着用户改用浏览器, 重装系统, 换新电脑, Ghost 还原就失效了. 给机器挖掘带来很大的杂音, 除在挖掘信息之前需要把不同的 Cookie 合并成一个人, 这个合并是不准确的, 再加上机器挖掘本身就不是很准确, 这样偏差就很大了, 处理起来很困难.</p>
<p>Google 的办法是用 Gmail, Google Reader, Gtalk, Google+, Google Docs 等免费好用的服务让你用, 让你自愿的将自己的搜索数据送给 Google. Baidu 这方面就做得不好, 一直没有像 Google 一样有一个 Gmail ID 打通自己的产品线, 用一个 Google ID 将一个人的行为统一收集起来.</p>
<p>360 的办法就更牛了, 通过客户端直接收集用户的行为: 不管你注册不注册 360 账号, 360 都可以把你的所有行为关联起来, 只要你用了 360 “安全浏览器”, 360 “安全卫士”, 360 “安全搜索”. 这样省去了把不同的 Cookie 合并成一个人这一高难度, 吃力做不好的事情, 精确定位到人, 精准投放广告, 变现能力变得比 Google 还强了.</p>
<p>所以说收集用户隐私是 360 的基因, 所以每日经济新闻发表了一篇<a href="http://epaper.nbd.com.cn/shtml/mrjjxw/20130226/118530.shtml">《360 黑匣子之谜——奇虎360“癌”性基因大揭秘》</a>, 才会让周红衣暴跳如雷, <a href="http://tech.163.com/13/0228/16/8OQK8N7T000915BF.html">起诉《每日经济新闻》</a>, 因为这简直要了 360 的命根子. 这就是为什么 360 在媒体的天天曝光下还要收集用户资料, 这就是 2012 年 <a href="http://news.163.com/12/0206/18/7PJM5MMR00014JB5.html">360产品被苹果应用商店全部下架</a>, 之后还不改, 今年又发生了除 360 云盘外的 <a href="http://www.techweb.com.cn/internet/2013-01-26/1273042.shtml">360 全部应用被苹果 从 App Store 下架</a>.</p>
<p>有人可能会说 Google 也是收集用户隐私, 360 也是收集用户隐私, 用户隐私难道是庙里的尼姑, Google 动得, 我 360 动不得. 这有个区别, Google 收集的只是你搜索和点击和浏览的记录, 而且还提供了工具给你<a href="https://www.google.com/settings/exportdata">查看下载</a>, 让你<a href="https://www.google.com/history/edit?authuser=0">删除</a>. 而且你是自愿给 Google 送过去的, 像很多人知道 Google 在收集信息, 也懒得在每次搜索前退出 Google 帐号. 360 则还收集你硬盘上的数据, 你使用电脑的记录, 还不承认它收集了, 更不要说提供给你查看, 删除的入口.</p>
<p>收集用户隐私违法吗, 这个不好界定, 现在也没有太完善的法律. 在美国去年<a href="http://www.guao.hk/posts/google-agrees-to-pay-hefty-22-5m-fine-in-safari-bypass-dispute.html">Google 就绕过 Safari 隐私控制的行为收集用户隐私被处 2250 万美元的罚款</a>. 美国人的隐私, 欧洲人的隐私是比较金贵的, 所以微软的 <a href="http://bing.com">Bing</a> 不会有前途. 中国人的隐私, 呵呵. 所以说 360 说 <a href="http://mobile.163.com/13/0227/22/8OOM5NRO0011665S.html">360 搜索 2015 年份额超 40%</a>. 我觉得是可能的, 40% 没有, 30% 总是有的.</p>
<h2 id="百度会坐以待毙吗">百度会坐以待毙吗</h2>
<p>简单来说答案是会的.</p>
<p>周红衣 做 “免费” 的安全卫士, 杀毒软件, 安全浏览器, 目的不是做活雷锋, 目的就是做搜索, 多年以前的他就只这么盘算的, 只是现在到了他收割的时候了. 你不让他收割能答应吗? 百度家大业大, 这种盗取用户隐私的事一是没能力做(Baidu 没有做客户端的基因), 二是不敢做, 这种会把自己置于风口浪尖的事风险太大(躺着也能竞价排名, 做这么高危的事情做什么?), 搞不好被竞争对手死命宣传, 偷鸡不成蚀把米就惨了. 360 不一样, Nothing to lose, 不做不能变现(参考 Sougou, Bing, Soso), 白做了这么久的雷锋, 做了争议大, 但是很大的可能能变现. 你会选择那样?</p>]]></summary>
</entry>
<entry>
    <title>企业级市场</title>
    <link href="http://veryr.com/posts/enterprise-market/" />
    <id>http://veryr.com/posts/enterprise-market/</id>
    <published>2013-02-20T00:00:00Z</published>
    <updated>2013-02-20T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="企业级市场">企业级市场</h2>
<p>黑莓给人的印象一直是专注于“企业级市场”，近些年在消费市场上节节败退。 与黑莓类似的还的一家公司：微软。微软的 Window Phone 8 发布好久了， Surface RT， Surface Pro 也上市了。但是反响貌似也不是很好，市场占有率一直上不去。这两家公司号称在企业级市场上有独到的优势，它们的消费电子市场上一塌糊涂还情有可原，可是现在他们在企业市场上也被 Google，苹果打得满地找牙，是什么原因呢？</p>
<h2 id="到底什么是企业级市场">到底什么是企业级市场</h2>
<p>我浅陋，也不太知道企业级市场是个什么东东。大概估计就是个企业采购的市场。我觉得下面的几个东西的大概就是企业级市场应用了：IBM Lotus， IE 6， 公司服务器上的 RHEL 5。 这些玩意有什么共同特征呢？</p>
<ol type="1">
<li>版本老，旧，基本上是10年前开发的，N久没更新了</li>
<li>难用，不想用</li>
<li>但是必需要用</li>
</ol>
<p>那我就明白了，到底什么是企业级市场。往好里说是追求稳定和安全在第一位的市场。一般采用了一个应用以后，会用很长一段时间，替换的成本很大。比如我们服务器上的 Centos 5.5, GCC 4.1.2，7，8年了也不能更新，安装个啥新软件都很费劲，安装一个 GHC 7.6 费了我一天多的时间。说得难听点就是绑架住用户，一旦用了以后要一直用，一直收钱，收钱还贼贵。</p>
<p>这个东西你偷偷做就行了，骗人骗久了，垄断的钱赚的太容易，自己智商也下降了，以为这真的是一个真正存在的“企业级市场”，还把这做为贵司的一个优势来宣传，真真让人笑掉大牙。微软花了天价的广告费宣传 Windows Phone，但是其销售没点起色，不是没有原因的。</p>
<p>差点忘了，还有一家企业在消费市场上不得意，也转向“企业级市场”。这是惠普，把刚买一年的Webos给废了，让无数Palm粉丝心灰意冷。怎么进军这个企业级市场呢？收购Autonomy，不曾想遭Autonomy财务欺诈亏损88亿美元，真是不好好做产品，想去“企业级市场”骗钱，反倒被骗子给骗了，真是活该。</p>
<p>根本就没有什么所谓的企业级市场，企业到底也是由人构成的，企业购买产品到底也是人用的。产品做的不好，想着绑架企业，迟早是要被抛弃的。像苹果没有特地去经营什么企业级市场，被企业内的人自下而上的推动，反而在企业级的销售情况变得越来越好。</p>]]></summary>
</entry>
<entry>
    <title>纯洁的 IO 与 自由的 Monad</title>
    <link href="http://veryr.com/posts/io-and-monad/" />
    <id>http://veryr.com/posts/io-and-monad/</id>
    <published>2012-08-29T00:00:00Z</published>
    <updated>2012-08-29T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="myths-and-legends">Myths and Legends</h2>
<p>Haskell 里 IO 操作也是纯函数，这多多少少会让初学者感情上难以接受。前几年 TopLanguage 就有几个哥们为 IO 是不是纯的争得面红耳赤，不欢而散。</p>
<p>在 Haskell 里面 IO 操作时是用 Monad 来建模的，一般的 IO 教程上会使用这样的模型来帮助理解：</p>
<pre><code>data IO a = IO (RealWorld -&gt; (RealWorld, a))</code></pre>
<p>这个模型的好处是易于理解。</p>
<h2 id="实现-io-monad">实现 IO Monad</h2>
<p>真正要理解一个概念，最好的办法就是实现它。在实现它的时候，为啥这个概念要这么设计，很多取舍你才会更深刻的理解它。</p>
<p>下面我们自己来实现一个 IO 库好了。</p>
<p>首先是 import, 先用 NoImplicitPrelude 防止自动引入 Prelude 里面预定义的 IO(我们要自己实现).</p>
<pre lang="haskell"><code>
{-# LANGUAGE DeriveFunctor, NoImplicitPrelude #-}
import Data.Function
import Data.Functor
import Data.String
import Control.Monad
import Prelude(Show(..), (++))
import qualified System.IO
import qualified System.Exit
</code></pre>
<p>定义三个基本的 IO 操作: GetLine, PutStr, Stop.</p>
<pre><code>data BasicIO next = GetLine (String -&gt; next) | PutStr String next | Stop
    deriving (Functor)</code></pre>
<p>定义一个 Helper 函数：</p>
<pre><code>class FunctorTrans t where
    liftF :: Functor f =&gt; f a -&gt; t f a

instance FunctorTrans Free where
    liftF = Free . fmap Pure</code></pre>
<p>定义三个 IO 函数: putStr, getLine, exit: 这是我们最经常用(如果不是唯一用的)的三个 IO 函数.</p>
<pre><code>putStr :: String -&gt; IO ()
putStr s = liftF $ PutStr s ()

getLine :: IO String
getLine = liftF $ GetLine id

exit :: IO a
exit = liftF Stop</code></pre>
<p>print 和 putStrLn 也是常用的， 当然需要定义一下:</p>
<pre><code>putStrLn :: String -&gt; IO ()
putStrLn = putStr . (++ &quot;\n&quot;)

print :: Show a =&gt; a -&gt; IO ()
print = putStrLn . show</code></pre>
<p>那上面的 IO 又是什么呢？ 下面我们就来定义一下：</p>
<pre><code>data Free f a = Pure a | Free (f (Free f a)) deriving (Functor)
type IO = Free BasicIO</code></pre>
<p>IO 是一个 Monad, 我们当然要实现：</p>
<pre><code>instance Functor f =&gt; Monad (Free f) where
    return = Pure
    Pure a &gt;&gt;= f = f a
    (Free x) &gt;&gt;= f = Free $ fmap (&gt;&gt;= f) x</code></pre>
<p>现在这个 IO 就可用了，不信的话，下面用上面定义的 IO 来写一段代码吧：</p>
<pre><code>freeMain = do
    x &lt;- getLine
    y &lt;- getLine
    putStrLn $ x ++ y
    exit
    putStrLn $ x ++ y</code></pre>
<p>到此为止，我们定义的 IO， 就算写完了。 这个 IO 是纯洁的吗？是。至少上面我们用到的都是纯函数。</p>
<p>那 IO Monad 真的是纯的吗？ 下面把我们自己当做 Haskell 的运行时。看一下 IO Monad 到底是怎么运行的：</p>
<pre><code>runIO :: IO a -&gt; System.IO.IO a
runIO (Pure a) = return a
runIO (Free (GetLine f)) = System.IO.getLine &gt;&gt;= runIO . f
runIO (Free (PutStr s next)) = System.IO.putStr s &gt;&gt; runIO next
runIO (Free Stop) = System.Exit.exitSuccess</code></pre>
<p>给个 main 函数运行一下：</p>
<pre><code>main = runIO freeMain</code></pre>
<h2 id="小结">小结</h2>
<p>Monad 是纯洁的吗？ 虽然在 IO Monad 执行的时候会用到不纯的 Syste.IO 里面的函数, 我们应该还是应该把 IO Monad 看成纯函数。 不能因为 runIO 的不纯就说 IO Monad 不纯。这件事我们应该从语义上去看，不应该从实现的手段去看。 比如我们用 C 语言写一个 Haskell 的解释器，C 语言里面都是副作用，那么在这个解释器里运行的 Haskell 代码是不纯的吗？</p>
<h2 id="从控制反转的角度来看-io-monad">从控制反转的角度来看 IO Monad</h2>
<p>上面的代码, 虽然用在 Haskell 中用纯函数实现了一个 IO Monad。但是还是不太直观。换个角度来看： 我们的 IO Monad 只是提供了一些 IO 操作的步骤，并没有真正的进行 IO，真正的 IO 操作是在 runIO 里面才被执行的。这个有点 IOC 的意思，熟悉数据库的老大可能就笑了，这个 IO Monad 不就是的 redo log 或 commit log 吗。先记下操作步骤，具体把数据写入 B-Tree 是等另一个进程 (runIO) 去做的。</p>
<h2 id="一点说明">一点说明</h2>
<p>上面的 Free Monad 是代数中的<a href="http://www.haskell.org/haskellwiki/Free_structure">Free Structure</a> 在 Haskell 中的对应物。其实简单的理解 Free BasicIO 就是 BasicIO 的一个列表 : <code>[BasicIO]</code>.</p>
<p>PS: Haskell 里面的这伙人真是变态，一个个仗着自己的医生(Doctor)头衔，写个代码都是各种抽象代数，范畴学的，绕到云里雾里。 最让人生气的是还能运行。。。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html">Haskell for all: Purify code using free monads</a></p>]]></summary>
</entry>
<entry>
    <title>在 Haskell 中使用 Continuation 实现单线程并发控制</title>
    <link href="http://veryr.com/posts/continuation-based-thread-in-haskell/" />
    <id>http://veryr.com/posts/continuation-based-thread-in-haskell/</id>
    <published>2012-08-23T00:00:00Z</published>
    <updated>2012-08-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>之前在 <a href="http://scheme.com/tspl4/further.html#./further:h3">Section 3.3. Continuations</a> 看到 Scheme 实现的一个用 call/cc 模拟的多任务程序, 还挺好玩的:</p>
<pre lang="scheme"><code>
    (define lwp-list &#39;())
    (define lwp
      (lambda (thunk)
        (set! lwp-list (append lwp-list (list thunk)))))

    (define start
      (lambda ()
        (let ([p (car lwp-list)])
          (set! lwp-list (cdr lwp-list))
          (p))))

    (define pause
      (lambda ()
        (call/cc
          (lambda (k)
            (lwp (lambda () (k #f)))
            (start)))))

    (lwp (lambda () (let f () (pause) (display &quot;h&quot;) (f))))
    (lwp (lambda () (let f () (pause) (display &quot;e&quot;) (f))))
    (lwp (lambda () (let f () (pause) (display &quot;y&quot;) (f))))
    (lwp (lambda () (let f () (pause) (display &quot;!&quot;) (f))))
    (lwp (lambda () (let f () (pause) (newline) (f))))
    (start)
</code></pre>
<p>这个程序会不断地输出: &gt;hey! &gt;hey! &gt;hey! &gt;hey! &gt;…</p>
<h2 id="热身">热身</h2>
<p>我估摸着吧, Haskell 里的 callCC 也可以这么玩，不过 Haskell 里面没有副作用，也就没有赋值，这个 <code>set!</code> 就需要绕个弯子, 借助 IORef 来实现了。</p>
<pre lang="haskell"><code>
import Control.Monad.Cont
import Data.IORef

main = (`runContT` return) $ do
    ref &lt;- lift $ newIORef undefined
    callCC $ \k -&gt; lift $ writeIORef ref k
    lift $ putStrLn &quot;print once&quot;
    continue &lt;- lift $ readIORef ref
    continue ()
</code></pre>
<p>稍微解释一下：这个程序会不断地打印 “print once”. 程序的执行过程是这样的，callCC 把 callCC 之后的三行代码绑定到 k 上了， 然后把 k 保存到 ref 里面。 这后三行代码呢，打印一个行 “print once”, 然后把保存在 ref 里的 k 拿出来，继续执行, 跳转到 callCC 那去了。 这样就形成了一个死循环，不断打印。</p>
<h2 id="模拟">模拟</h2>
<p>接下来就简单了，依葫芦画瓢抡一个 Haskell 版本的 light weight process 了 :</p>
<pre lang="haskell"><code>
    import Control.Monad.Cont
    import Data.IORef

    pause ref = callCC $ \k -&gt; do
        lwp ref (k ())
        start ref

    start ref = do
        (t:ts) &lt;- lift $ readIORef ref
        lift $ writeIORef ref ts
        t

    lwp ref t = lift $ modifyIORef ref $ \ts -&gt; ts ++ [t]

    main = (`runContT` return) $ do
        ref &lt;- lift $ newIORef []
        lwp ref . forever $ do
            pause ref
            lift $ putStrLn &quot;Hello&quot;
        lwp ref . forever $ do
            pause ref
            lift $ putStrLn &quot;World&quot;
        start ref</code></pre>
<p>这个程序呢，不断打印 “Hello World”, 几乎就是原来 Scheme 版本的一一对应， 没啥好解释的了。</p>
<h2 id="后话">后话</h2>
<p>ps: The Scheme Programming Language 真是一本好书。 前三章就把 Scheme 编程的要素讲完了， 包括 Continuation, CPS, 宏定义等都讲透了， 后面九章就是具体解释和应用了。Kent Dybvig 端的是功力深厚，学术一流，工程能力也没话说, Chez petite 编译器不管易用性，性能都是一等一的。话说作者还把这本书公开放在网上了: http://www.scheme.com/tspl4/ , 真的是功德无量哈。SICP 固然是好书，不过里面讲 Scheme 的东西其实不多，看过 SICP 的来看这本，想必会如或至宝。SICP 练就一身内力，不过不好使出来 (小测验: 用 Scheme 编写一个文件读写的程序?), 这本 TSPL 就是教你太极招式的好书。</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a href="http://scheme.com/tspl4">The Scheme Programming Language</a></li>
</ol>]]></summary>
</entry>
<entry>
    <title>8 皇后的 Haskell 解法</title>
    <link href="http://veryr.com/posts/queens/" />
    <id>http://veryr.com/posts/queens/</id>
    <published>2012-08-07T00:00:00Z</published>
    <updated>2012-08-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>八皇后谜题问的是怎样将八个皇后摆在国际象棋棋盘上. 使得任意一个皇后都不能攻击另一个皇后(也就是说, 任意两个皇后都不在同一行、同一列或者同一对角线上).</p>
<h2 id="前人的解法">前人的解法</h2>
<p>albertlee 大牛的Haskell解法：</p>
<pre lang="haskell"><code>
import Control.Monad
import Control.Monad.Writer
import Data.List
diagonal (x1,y1) (x2,y2) = x1 + y1 == x2 + y2
                        || x1 - y1 == x2 - y2
nqueens n = execWriter $ f [1..n] 1 []
    where f [] _ ps = tell [ps]
          f cs r ps = forM_ cs $ \c -&gt;
                          unless (any (diagonal (r,c)) ps) $
                              f (delete c cs) (r + 1) ((r,c):ps)
main = print $ nqueens 4
</code></pre>
<ul>
<li><a href="http://fleurer-lee.com/2009/04/03/haskellqiu-jie-nhuang-hou-wen-ti.html">haskell求解n皇后问题</a> : fleuria 大牛的解法</li>
<li><a href="http://www.iteye.com/topic/106747">用 Python 秒掉八皇后问题！</a> : 众多大牛的解法.</li>
</ul>
<h2 id="有没有简单点的">有没有简单点的</h2>
<p>我愚钝，没看懂。只好自己也想一个解法：</p>
<pre><code>import Data.List
queens n = filter valid $ map (zip ([1..n])) $ permutations [1..n]
valid [] = True
valid ((a,b):xs) = all (\(x,y) -&gt; abs(a-x) /= abs(b-y)) xs &amp;&amp; valid xs

--6 皇后
*Main&gt; queens 6
[[(1,2),(2,4),(3,6),(4,1),(5,3),(6,5)],[(1,5),(2,3),(3,1),(4,6),(5,4),(6,2)],[(1,3),(2,6),(3,2),(4,5),(5,1),(6,4)],[(1,4),(2,1),(3,5),(4,2),(5,6),(6,3)]]</code></pre>
<p>运行的还是挺慢的. 不过代码应该很好懂, 我再解释一下: <code>map (zip ([1..n])) $ permutations [1..n]</code>生成所有皇后可能的排列, 用<code>filter valid</code>筛选出皇后之间没有冲突的就行了.</p>
<h2 id="参考文献">参考文献</h2>]]></summary>
</entry>
<entry>
    <title>Monad 的意义</title>
    <link href="http://veryr.com/posts/monad-purpose/" />
    <id>http://veryr.com/posts/monad-purpose/</id>
    <published>2012-07-07T00:00:00Z</published>
    <updated>2012-07-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="haskell-的意义">Haskell 的意义</h2>
<p>学习 haskell, 基本上大家的第一个反应是学这东西有什么用? 也是, 学习一个东西之前知道这玩意有啥用, 才有动力去学. 想当年, 刚开始学线性代数的时侯, 矩阵变换来变换去, 我就一直耿耿于怀: 变来变去搞什么名堂, 有啥子用? 因此, 线性代数就没学好. 考试考完就全忘了. 后来才发现这玩意用处还不小: 可以解多元方程, 可意做图形学上的空间变换, 重新捡起书本, 我才对线性代数有了点印象. 学习 Haskell 有甚么用处呢. 现在想来, 用处也不大, 主要还是兴趣. Haskell 是一门很优美的语言, 虽然也有一些来源于兼容性的妥协, 但是大体上而言, Haskell 简单, 一致, 正交, 静态类型, 高性能, 基本符合个人对一门完美编程语言的要求. Monad 的意义</p>
<p>任何学习 Haskell 的一大成就或者说一大障碍就是 Monad. 好多人学 Haskell 学到 Monad 这一章不禁疑窦丛生: 这劳什子做什么的, 未啥别的语言里面都没遇到过? 下面我就试试来说说 Monad 有甚么意义.</p>
<h2 id="抽象是程序设计的根本方法">抽象是程序设计的根本方法</h2>
<p>CPU 是电路的的抽象, 汇编是 CPU (硬件) 抽象, 操作系统(系统调用)是汇编的抽象. C 语言是操作系统的抽象.</p>
<p>当程序设计发展到今天, 一个人不太可能象 Donald E. Knuth 一样通晓所有算法. 不太可能象 Bill Joy 一样 3 天写出个操作系统. 各种繁复的功能和硬件被抽象成了几个类库让大家去调用. 大家只要知道类库怎么使用就行了, 不需要知道其实现的原理.</p>
<h2 id="haskell-的抽象方法-functor">Haskell 的抽象方法 : Functor</h2>
<p>Haskell 可以使用 ADT 做数据抽象, 例如:</p>
<pre><code>data Maybe a = ...
data [a] = ...
data IO a = ...</code></pre>
<p>代表的分别是 可能不存在的 a, a 类型的一个列表, a 类型的一个 IO. 具体 <code>Maybe</code>, <code>[]</code>, <code>IO</code> 是怎么定义的实际上我们都不需要关心.</p>
<p>假设我们不知道<code>Maybe</code>, <code>[]</code>, <code>IO</code> 的内部结构, 我们可以对其进行操作吗? 答案是可以. 但是需要该抽象数据类型满足一个条件: 它必须是一个 <code>Functor</code>.</p>
<pre><code>class Functor f where
fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>fmap 这个函数有甚么意义呢? fmap将一个函数从一个域变换到 f (f 可以是 <code>Maybe</code>, <code>[]</code>, <code>IO</code> , …)域. 比如我们在 Int 上有一个后继数函数 succ. 那么我们就可以将其变换到 Maybe 域:</p>
<pre><code>fmap succ (Just 1) == Just 2
fmap succ Nothing == Nothing
m1 = Just 10
m2 = Nothing
fmap succ m1
fmap succ m2</code></pre>
<p>可以将其变换到List 域:</p>
<pre><code>fmap succ [1,2,3] == [2,3,4]
fmap succ [] == []</code></pre>
<p>可以将函数其变换到IO 域:</p>
<pre><code>fmap reverse getLine</code></pre>
<p>我们完全不用关心m1, m2, Just 10, getLine 的内部结构是怎么样的, 我们就可以对其内容进行操作了.</p>
<p>我们如果有 <code>Int, Double, Float, String</code> 上的函数, 通过 fmap , 我们不费吹灰之力就有了 <code>Maybe Int, Maybe Double, Maybe String, [Int], [Double], [String], IO Int , IO String , Writer w Int, Reader r String, State s Double</code> … 上的函数. 这就是抽象的威力.</p>
<h2 id="数据的映射-appicative">数据的映射 :: Appicative</h2>
<p>上面讲到fmap 将函数 <code>a -&gt; b</code> 变换成 <code>f a -&gt; f b</code>. 假如 <code>f</code> 是完全抽象的， 我们怎么的到一个 <code>f a</code> 呢? 这就不仅要变换函数, 还要变换数据. 这就是 Applicative class要解决的问题.</p>
<pre><code>class Functor f =&gt; Applicative f where
  pure :: a -&gt; f a
  &lt;*&gt; :: f (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>先来看 pure. pure 可以将一个 a 变换成 <code>f a</code> , 例如:</p>
<pre><code>pure 1 == Just 1
pure 1 == [1]
pure &quot;type this string&quot; -- == getLine 输入 &quot;type this string&quot;</code></pre>
<p>函数实际上也是数据，那么 <code>pure succ</code>　也是可以的. 但是 pure succ 的类型是 <code>f (Int -&gt; Int)</code>. 这个函数我们能拿来干什么呢. 貌似啥都干不了, 因为这个函数被包裹在 f 里面了, 我们不能把他拿出来，不能喂给他一个 Int, 吐出一个Int.</p>
<p>这时候 <code>&lt;*&gt;</code> 就很有用了. 它能够将 <code>f(a -&gt; b)</code> 这个数据变成一个 <code>f a -&gt; f b</code> 的函数. 有了这个函数实际上我们都可以不需要fmap了因为:</p>
<p>pure　把一个函数 <code>a -&gt; b</code> 变换成 <code>f(a -&gt; b)</code>, <code>&lt;*&gt;</code> 把 <code>f(a -&gt; b)</code> 变换成 <code>f a -&gt; f b</code>. 两个一结合:</p>
<pre><code>(&lt;*&gt;) . pure :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>再回顾下 fmap 的类型:</p>
<pre><code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code></pre>
<p>因此:</p>
<pre><code>fmap == (&lt;*&gt;) . pure</code></pre>
<p>到此, 我们已经能加任意类型 a, b 以及他们直接的函数 <code>a -&gt; b</code> 转换到 f 域上了.</p>
<p>现在我们就可以对任意 f 域里面的数据进行操作了. 例如对 IO a :</p>
<pre><code>-- t.hs
import Control.Applicative
import Data.List(sort)

(==&gt;) :: Applicative f =&gt; f a -&gt; (a -&gt; b) -&gt; f b
a ==&gt; g = fmap g a

main= getLine ==&gt; words ==&gt; map read ==&gt; (sort::[Int] -&gt; [Int])</code></pre>
<p>main 函数把 <code>getLine :: IO String</code> 变成有序的 <code>IO [Int]</code>, 在我们完全不知道 IO a 的内部构造的条件下.</p>
<p>运行一下:</p>
<pre><code>[root@myhost:tmp]$ ghci t.hs
GHCi, version 7.4.1: http://www.haskell.org/ghc/  :? for help
Loading package ghc-prim ... linking ... done.
Loading package integer-gmp ... linking ... done.
Loading package base ... linking ... done.
[1 of 1] Compiling Main             ( t.hs, interpreted )
Ok, modules loaded: Main.
*Main&gt; main
1 3 2 4
[1,2,3,4]
*Main&gt;</code></pre>
<h2 id="两个世界之间的联系-monad">两个世界之间的联系: Monad</h2>
<p>到目前为止, 我们接触到的从世界 a 到 f a 的函数只有 return 一个.</p>
<p>实际上这种转换函数有很多．</p>
<p>假如我们要有很多 <code>a -&gt; f a</code> 的函数，　怎么把它复合合起来呢？</p>
<p>假如我们有这个三个函数 检查输入是否是个数，是个非负数，是个偶数 :</p>
<pre><code>import Control.Applicative

parseInt :: String -&gt; Maybe Int
parseInt s = let xs = reads s in if null xs then Nothing else pure.fst.head $ xs

notNegative :: Int -&gt; Maybe Int
notNegative i = if i &lt; 0 then Nothing else pure i

notOdd :: Int -&gt; Maybe Int
notOdd x = if mod x 2 == 0 then pure x else Nothing</code></pre>
<p>最简单的, 我们采用Applicative 函数去复合他们</p>
<pre><code>checkArg :: String -&gt; Maybe (Maybe Int)
checkArg arg= (fmap $ fmap notOdd) $ (fmap notNegative) (parseInt arg)
-- checkArg &quot;1234&quot; == Just (Just 1234)
-- checkArg &quot;-1&quot; == Just Nothing
-- checkArg &quot;abc&quot; == Nothing</code></pre>
<p>问题来了. 不好复用. 多几层检查的话我们的函数签名就要变成 <code>Maybe (Maybe (Maybe (Maybe (Maybe ...))))</code> 了, 那就是 Lisp 了. :D</p>
<p>因此我们需要一个把 Maybe (Maybe Int) 变成 Maybe Int 的一个机制. 当当当:</p>
<pre><code>class Applicative m =&gt; Monad m where
  join :: m (m a) -&gt; m a</code></pre>
<p>这就是所谓的 Monad 了.</p>
<p>上面的例子, 就变成这样:</p>
<pre><code>checkArg2 :: String -&gt; Maybe Int
checkArg2 = join.fmap notOdd.join.fmap notNegative.parseInt</code></pre>
<p>后来呢, 人们嫌每次函数复合都写 join.fmap 太费劲, 于是就整了个语法糖:</p>
<pre><code>(&gt;&gt;=) :: Monad m =&gt; m a -&gt; (a -&gt; m b) -&gt; m b
m &gt;&gt;= f = join $ fmap f m</code></pre>
<p>于是</p>
<pre><code>checkArg3 arg = parseInt arg &gt;&gt;= notNegative &gt;&gt;= notOdd</code></pre>
<p>顺眼多了吧.</p>
<h2 id="参考文献">参考文献</h2>
<ol type="1">
<li><a href="http://www.iteye.com/topic/147443">回albertLee:关于Category Theory 和Monad</a></li>
<li><a href="http://yi-programmer.com/2010-04-06_haskell_and_category_translate.html">Haskell与范畴论</a></li>
</ol>]]></summary>
</entry>

</feed>
